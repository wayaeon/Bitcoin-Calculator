// Bitcoin Historical Data Integration
// This file handles loading and processing the Kaggle Bitcoin historical dataset

export interface BTCHistoricalData {
  timestamp: string
  open: number
  high: number
  low: number
  close: number
  volume: number
  market_cap?: number
}

export interface ProcessedBTCData {
  date: string
  price: number
  volume: number
  marketCap?: number
  change: number
  changePercent: number
}

// Load historical data from JSON file (generated by Python script)
export async function loadBTCHistoricalData(): Promise<BTCHistoricalData[]> {
  try {
    console.log('Loading Bitcoin historical data from JSON file...')
    
    // Try to load from the JSON file generated by the Python script
    const response = await fetch('/data/bitcoin-historical.json')
    
    if (!response.ok) {
      throw new Error(`Failed to load historical data: ${response.status}`)
    }
    
    const data = await response.json()
    console.log(`Loaded ${data.length} historical records`)
    
    return data as BTCHistoricalData[]
    
  } catch (error) {
    console.error('Error loading historical data:', error)
    console.log('Falling back to mock data...')
    
    // Fallback to mock data if JSON file is not available
    return getMockHistoricalData()
  }
}

// Mock data for fallback
function getMockHistoricalData(): BTCHistoricalData[] {
  const mockData: BTCHistoricalData[] = []
  
  // Generate comprehensive mock data from 2020 to 2024
  const startDate = new Date('2020-01-01')
  const endDate = new Date('2024-12-31')
  const currentDate = new Date(startDate)
  
  let basePrice = 8000 // Starting price in 2020
  
  while (currentDate <= endDate) {
    // Simulate realistic Bitcoin price movements
    const daysSinceStart = Math.floor((currentDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))
    
    // Add trend, cycles, and noise
    const trend = daysSinceStart * 15 // Upward trend
    const cycle = Math.sin(daysSinceStart * 0.01) * 10000 // Cyclical pattern
    const noise = (Math.random() - 0.5) * 5000 // Random noise
    
    const price = Math.max(basePrice + trend + cycle + noise, 3000) // Minimum price
    
    const open = price - (Math.random() * 1000 - 500)
    const high = price + Math.random() * 2000
    const low = price - Math.random() * 2000
    const close = price
    
    const volume = 15000000000 + Math.random() * 10000000000
    const marketCap = close * 19000000
    
    mockData.push({
      timestamp: currentDate.toISOString().split('T')[0],
      open,
      high,
      low,
      close,
      volume,
      market_cap: marketCap
    })
    
    // Move to next day
    currentDate.setDate(currentDate.getDate() + 1)
  }
  
  return mockData
}

// Process historical data for chart display
export function processHistoricalData(data: BTCHistoricalData[]): ProcessedBTCData[] {
  return data.map((item, index) => {
    const previousClose = index > 0 ? data[index - 1].close : item.open
    const change = item.close - previousClose
    const changePercent = (change / previousClose) * 100
    
    return {
      date: item.timestamp,
      price: item.close,
      volume: item.volume,
      marketCap: item.market_cap,
      change,
      changePercent
    }
  })
}

// Get data for specific time range
export function filterDataByTimeRange(
  data: ProcessedBTCData[], 
  startDate: string, 
  endDate: string
): ProcessedBTCData[] {
  return data.filter(item => {
    const itemDate = new Date(item.date)
    const start = new Date(startDate)
    const end = new Date(endDate)
    return itemDate >= start && itemDate <= end
  }).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
}

// Calculate statistics from historical data
export function calculateHistoricalStats(data: ProcessedBTCData[]) {
  if (data.length === 0) return null
  
  const prices = data.map(d => d.price)
  const volumes = data.map(d => d.volume)
  
  const currentPrice = data[data.length - 1].price
  const startPrice = data[0].price
  const totalChange = currentPrice - startPrice
  const totalChangePercent = (totalChange / startPrice) * 100
  
  const maxPrice = Math.max(...prices)
  const minPrice = Math.min(...prices)
  const avgVolume = volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length
  
  return {
    currentPrice,
    startPrice,
    totalChange,
    totalChangePercent,
    maxPrice,
    minPrice,
    avgVolume,
    dataPoints: data.length
  }
}

// Integration with existing calculator
export function enhanceCalculatorWithHistoricalData(
  historicalData: ProcessedBTCData[],
  currentPrice: number
) {
  // Use historical data to improve calculator accuracy
  const stats = calculateHistoricalStats(historicalData)
  
  if (!stats) return null
  
  // Calculate historical volatility
  const returns = historicalData.slice(1).map((item, index) => {
    const previousPrice = historicalData[index].price
    return (item.price - previousPrice) / previousPrice
  })
  
  const volatility = Math.sqrt(
    returns.reduce((sum, ret) => sum + ret * ret, 0) / returns.length
  )
  
  return {
    historicalVolatility: volatility,
    historicalStats: stats,
    dataQuality: historicalData.length > 100 ? 'high' : 'low'
  }
} 